"""
Performance Monitoring and Alerting System

Comprehensive monitoring system for tracking performance metrics,
detecting issues, and sending alerts for the optimized chat system.
"""

import asyncio
import time
import statistics
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional, Callable
from dataclasses import dataclass, field
from enum import Enum
import structlog

from config.performance_config import get_performance_config

logger = structlog.get_logger(__name__)


class AlertLevel(Enum):
    """Alert severity levels."""
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"


class MetricType(Enum):
    """Types of metrics being tracked."""
    RESPONSE_TIME = "response_time"
    CACHE_HIT_RATE = "cache_hit_rate"
    ERROR_RATE = "error_rate"
    MEMORY_USAGE = "memory_usage"
    WEBSOCKET_CONNECTIONS = "websocket_connections"
    THROUGHPUT = "throughput"
    LATENCY = "latency"


@dataclass
class MetricPoint:
    """A single metric data point."""
    timestamp: datetime
    value: float
    metric_type: MetricType
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Alert:
    """An alert generated by the monitoring system."""
    id: str
    level: AlertLevel
    metric_type: MetricType
    message: str
    value: float
    threshold: float
    timestamp: datetime
    resolved: bool = False
    resolved_at: Optional[datetime] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


class MetricBuffer:
    """Circular buffer for storing metric data points."""
    
    def __init__(self, max_size: int = 1000):
        self.max_size = max_size
        self.data: List[MetricPoint] = []
        self.current_index = 0
    
    def add(self, point: MetricPoint):
        """Add a metric point to the buffer."""
        if len(self.data) < self.max_size:
            self.data.append(point)
        else:
            self.data[self.current_index] = point
            self.current_index = (self.current_index + 1) % self.max_size
    
    def get_recent(self, minutes: int = 5) -> List[MetricPoint]:
        """Get metric points from the last N minutes."""
        cutoff_time = datetime.now() - timedelta(minutes=minutes)
        return [point for point in self.data if point.timestamp >= cutoff_time]
    
    def get_statistics(self, minutes: int = 5) -> Dict[str, float]:
        """Get statistical summary of recent metric points."""
        recent_points = self.get_recent(minutes)
        if not recent_points:
            return {}
        
        values = [point.value for point in recent_points]
        return {
            "count": len(values),
            "min": min(values),
            "max": max(values),
            "mean": statistics.mean(values),
            "median": statistics.median(values),
            "std_dev": statistics.stdev(values) if len(values) > 1 else 0.0
        }


class ThresholdChecker:
    """Checks metric values against configured thresholds."""
    
    def __init__(self):
        self.performance_config = get_performance_config()
        self.thresholds = self.performance_config.get_monitoring_thresholds()
        self.active_alerts: Dict[str, Alert] = {}
        self.alert_cooldowns: Dict[str, datetime] = {}
    
    def check_thresholds(self, metric_point: MetricPoint) -> List[Alert]:
        """Check if a metric point violates any thresholds."""
        alerts = []
        
        metric_name = metric_point.metric_type.value
        if metric_name not in self.thresholds:
            return alerts
        
        thresholds = self.thresholds[metric_name]
        value = metric_point.value
        
        # Check critical threshold first
        if "critical" in thresholds and value >= thresholds["critical"]:
            alert = self._create_alert(metric_point, AlertLevel.CRITICAL, thresholds["critical"])
            if alert:
                alerts.append(alert)
        
        # Check warning threshold
        elif "warning" in thresholds and value >= thresholds["warning"]:
            alert = self._create_alert(metric_point, AlertLevel.WARNING, thresholds["warning"])
            if alert:
                alerts.append(alert)
        
        # Check if we should resolve any existing alerts
        else:
            resolved_alert = self._check_alert_resolution(metric_point)
            if resolved_alert:
                alerts.append(resolved_alert)
        
        return alerts
    
    def _create_alert(self, metric_point: MetricPoint, level: AlertLevel, threshold: float) -> Optional[Alert]:
        """Create an alert if not in cooldown period."""
        alert_key = f"{metric_point.metric_type.value}_{level.value}"
        
        # Check cooldown
        if alert_key in self.alert_cooldowns:
            cooldown_end = self.alert_cooldowns[alert_key] + timedelta(
                minutes=self.performance_config.monitoring_config.alert_cooldown_minutes
            )
            if datetime.now() < cooldown_end:
                return None
        
        # Create alert
        alert_id = f"{alert_key}_{int(time.time())}"
        alert = Alert(
            id=alert_id,
            level=level,
            metric_type=metric_point.metric_type,
            message=self._generate_alert_message(metric_point, level, threshold),
            value=metric_point.value,
            threshold=threshold,
            timestamp=metric_point.timestamp,
            metadata=metric_point.metadata
        )
        
        self.active_alerts[alert_key] = alert
        self.alert_cooldowns[alert_key] = datetime.now()
        
        return alert
    
    def _check_alert_resolution(self, metric_point: MetricPoint) -> Optional[Alert]:
        """Check if any active alerts should be resolved."""
        alert_key_warning = f"{metric_point.metric_type.value}_warning"
        alert_key_critical = f"{metric_point.metric_type.value}_critical"
        
        for alert_key in [alert_key_critical, alert_key_warning]:
            if alert_key in self.active_alerts:
                active_alert = self.active_alerts[alert_key]
                
                # Check if value is now below threshold
                if metric_point.value < active_alert.threshold * 0.9:  # 10% buffer to prevent flapping
                    active_alert.resolved = True
                    active_alert.resolved_at = datetime.now()
                    
                    # Remove from active alerts
                    del self.active_alerts[alert_key]
                    
                    return active_alert
        
        return None
    
    def _generate_alert_message(self, metric_point: MetricPoint, level: AlertLevel, threshold: float) -> str:
        """Generate a human-readable alert message."""
        metric_name = metric_point.metric_type.value.replace("_", " ").title()
        
        if metric_point.metric_type == MetricType.RESPONSE_TIME:
            return f"{level.value.upper()}: {metric_name} is {metric_point.value:.2f}ms (threshold: {threshold:.2f}ms)"
        elif metric_point.metric_type == MetricType.CACHE_HIT_RATE:
            return f"{level.value.upper()}: {metric_name} is {metric_point.value:.2%} (threshold: {threshold:.2%})"
        elif metric_point.metric_type == MetricType.ERROR_RATE:
            return f"{level.value.upper()}: {metric_name} is {metric_point.value:.2%} (threshold: {threshold:.2%})"
        elif metric_point.metric_type == MetricType.MEMORY_USAGE:
            return f"{level.value.upper()}: {metric_name} is {metric_point.value:.1f}MB (threshold: {threshold:.1f}MB)"
        elif metric_point.metric_type == MetricType.WEBSOCKET_CONNECTIONS:
            return f"{level.value.upper()}: {metric_name} is {int(metric_point.value)} (threshold: {int(threshold)})"
        else:
            return f"{level.value.upper()}: {metric_name} is {metric_point.value:.2f} (threshold: {threshold:.2f})"


class PerformanceMonitor:
    """Main performance monitoring system."""
    
    def __init__(self):
        self.performance_config = get_performance_config()
        self.metric_buffers: Dict[MetricType, MetricBuffer] = {}
        self.threshold_checker = ThresholdChecker()
        self.alert_handlers: List[Callable[[Alert], None]] = []
        self.is_running = False
        self.monitoring_task: Optional[asyncio.Task] = None
        
        # Initialize metric buffers
        for metric_type in MetricType:
            self.metric_buffers[metric_type] = MetricBuffer()
    
    def add_alert_handler(self, handler: Callable[[Alert], None]):
        """Add an alert handler function."""
        self.alert_handlers.append(handler)
    
    def record_metric(self, metric_type: MetricType, value: float, metadata: Dict[str, Any] = None):
        """Record a metric value."""
        point = MetricPoint(
            timestamp=datetime.now(),
            value=value,
            metric_type=metric_type,
            metadata=metadata or {}
        )
        
        # Add to buffer
        if metric_type in self.metric_buffers:
            self.metric_buffers[metric_type].add(point)
        
        # Check thresholds
        alerts = self.threshold_checker.check_thresholds(point)
        
        # Send alerts
        for alert in alerts:
            self._send_alert(alert)
    
    def _send_alert(self, alert: Alert):
        """Send an alert to all registered handlers."""
        logger.info("Performance alert generated",
                   alert_id=alert.id,
                   level=alert.level.value,
                   metric=alert.metric_type.value,
                   message=alert.message,
                   value=alert.value,
                   threshold=alert.threshold)
        
        for handler in self.alert_handlers:
            try:
                handler(alert)
            except Exception as e:
                logger.error("Alert handler failed", handler=str(handler), error=str(e))
    
    def get_metric_statistics(self, metric_type: MetricType, minutes: int = 5) -> Dict[str, Any]:
        """Get statistics for a specific metric type."""
        if metric_type not in self.metric_buffers:
            return {}
        
        buffer = self.metric_buffers[metric_type]
        stats = buffer.get_statistics(minutes)
        recent_points = buffer.get_recent(minutes)
        
        return {
            "metric_type": metric_type.value,
            "time_range_minutes": minutes,
            "statistics": stats,
            "recent_values": [{"timestamp": p.timestamp.isoformat(), "value": p.value} 
                            for p in recent_points[-10:]]  # Last 10 points
        }
    
    def get_all_statistics(self, minutes: int = 5) -> Dict[str, Any]:
        """Get statistics for all metric types."""
        return {
            metric_type.value: self.get_metric_statistics(metric_type, minutes)
            for metric_type in MetricType
        }
    
    def get_active_alerts(self) -> List[Alert]:
        """Get all currently active alerts."""
        return list(self.threshold_checker.active_alerts.values())
    
    def get_system_health_summary(self) -> Dict[str, Any]:
        """Get overall system health summary."""
        active_alerts = self.get_active_alerts()
        
        # Count alerts by level
        alert_counts = {level.value: 0 for level in AlertLevel}
        for alert in active_alerts:
            alert_counts[alert.level.value] += 1
        
        # Determine overall health status
        if alert_counts["critical"] > 0:
            health_status = "critical"
        elif alert_counts["warning"] > 0:
            health_status = "warning"
        else:
            health_status = "healthy"
        
        # Get recent performance summary
        performance_summary = {}
        for metric_type in [MetricType.RESPONSE_TIME, MetricType.CACHE_HIT_RATE, 
                           MetricType.ERROR_RATE, MetricType.MEMORY_USAGE]:
            stats = self.get_metric_statistics(metric_type, minutes=5)
            if stats and "statistics" in stats and stats["statistics"]:
                performance_summary[metric_type.value] = {
                    "current": stats["statistics"].get("mean", 0),
                    "trend": "stable"  # Could be enhanced with trend analysis
                }
        
        return {
            "health_status": health_status,
            "active_alerts": len(active_alerts),
            "alert_breakdown": alert_counts,
            "performance_summary": performance_summary,
            "timestamp": datetime.now().isoformat()
        }
    
    async def start_monitoring(self):
        """Start the monitoring system."""
        if self.is_running:
            return
        
        self.is_running = True
        self.monitoring_task = asyncio.create_task(self._monitoring_loop())
        
        logger.info("Performance monitoring system started",
                   collection_interval=self.performance_config.monitoring_config.metrics_collection_interval)
    
    async def stop_monitoring(self):
        """Stop the monitoring system."""
        self.is_running = False
        
        if self.monitoring_task:
            self.monitoring_task.cancel()
            try:
                await self.monitoring_task
            except asyncio.CancelledError:
                pass
        
        logger.info("Performance monitoring system stopped")
    
    async def _monitoring_loop(self):
        """Main monitoring loop."""
        interval = self.performance_config.monitoring_config.metrics_collection_interval
        
        while self.is_running:
            try:
                await self._collect_system_metrics()
                await asyncio.sleep(interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error("Error in monitoring loop", error=str(e))
                await asyncio.sleep(interval)
    
    async def _collect_system_metrics(self):
        """Collect system-wide metrics."""
        try:
            # This would integrate with actual system components
            # For now, we'll record some basic metrics
            
            # Record current timestamp as a heartbeat
            self.record_metric(MetricType.THROUGHPUT, 1.0, {"type": "heartbeat"})
            
            logger.debug("System metrics collected")
            
        except Exception as e:
            logger.error("Failed to collect system metrics", error=str(e))


class AlertHandlers:
    """Collection of alert handler functions."""
    
    @staticmethod
    def log_alert_handler(alert: Alert):
        """Log alerts to the application log."""
        log_level = "error" if alert.level == AlertLevel.CRITICAL else "warning"
        
        logger.log(log_level, "Performance Alert",
                  alert_id=alert.id,
                  level=alert.level.value,
                  metric=alert.metric_type.value,
                  message=alert.message,
                  value=alert.value,
                  threshold=alert.threshold,
                  resolved=alert.resolved)
    
    @staticmethod
    def console_alert_handler(alert: Alert):
        """Print alerts to console."""
        status = "RESOLVED" if alert.resolved else "ACTIVE"
        print(f"[{status}] {alert.level.value.upper()}: {alert.message}")
    
    @staticmethod
    def webhook_alert_handler(alert: Alert):
        """Send alerts to a webhook (placeholder implementation)."""
        # This would send alerts to external systems like Slack, PagerDuty, etc.
        logger.info("Webhook alert sent", alert_id=alert.id, message=alert.message)


# Global monitoring instance
_performance_monitor = None


def get_performance_monitor() -> PerformanceMonitor:
    """Get the global performance monitor instance."""
    global _performance_monitor
    if _performance_monitor is None:
        _performance_monitor = PerformanceMonitor()
        
        # Add default alert handlers
        _performance_monitor.add_alert_handler(AlertHandlers.log_alert_handler)
        
        # Add console handler in development
        import os
        if os.getenv("ENVIRONMENT", "development") == "development":
            _performance_monitor.add_alert_handler(AlertHandlers.console_alert_handler)
    
    return _performance_monitor


async def start_performance_monitoring():
    """Start the global performance monitoring system."""
    monitor = get_performance_monitor()
    await monitor.start_monitoring()


async def stop_performance_monitoring():
    """Stop the global performance monitoring system."""
    global _performance_monitor
    if _performance_monitor:
        await _performance_monitor.stop_monitoring()


# Convenience functions for recording metrics
def record_response_time(response_time_ms: float, endpoint: str = None):
    """Record a response time metric."""
    monitor = get_performance_monitor()
    metadata = {"endpoint": endpoint} if endpoint else {}
    monitor.record_metric(MetricType.RESPONSE_TIME, response_time_ms, metadata)


def record_cache_hit_rate(hit_rate: float, cache_type: str = None):
    """Record a cache hit rate metric."""
    monitor = get_performance_monitor()
    metadata = {"cache_type": cache_type} if cache_type else {}
    monitor.record_metric(MetricType.CACHE_HIT_RATE, hit_rate, metadata)


def record_error_rate(error_rate: float, service: str = None):
    """Record an error rate metric."""
    monitor = get_performance_monitor()
    metadata = {"service": service} if service else {}
    monitor.record_metric(MetricType.ERROR_RATE, error_rate, metadata)


def record_memory_usage(memory_mb: float, component: str = None):
    """Record a memory usage metric."""
    monitor = get_performance_monitor()
    metadata = {"component": component} if component else {}
    monitor.record_metric(MetricType.MEMORY_USAGE, memory_mb, metadata)


def record_websocket_connections(connection_count: int):
    """Record WebSocket connection count."""
    monitor = get_performance_monitor()
    monitor.record_metric(MetricType.WEBSOCKET_CONNECTIONS, float(connection_count))