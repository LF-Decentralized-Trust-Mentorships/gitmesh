"""
WebSocket routes for real-time notification functionality.
"""

import json
import asyncio
from typing import Dict, Set
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, HTTPException, Depends, Query
from fastapi.websockets import WebSocketState
import structlog
import uuid
from datetime import datetime

from utils.auth_utils import jwt_handler

logger = structlog.get_logger(__name__)
router = APIRouter()

# Store active WebSocket connections
class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
        self.user_connections: Dict[str, Set[str]] = {}  # user_id -> set of connection_ids
    
    async def connect(self, websocket: WebSocket, connection_id: str, user_id: str = None):
        """Accept a WebSocket connection and store it"""
        await websocket.accept()
        self.active_connections[connection_id] = websocket
        
        if user_id:
            if user_id not in self.user_connections:
                self.user_connections[user_id] = set()
            self.user_connections[user_id].add(connection_id)
        
        logger.info("WebSocket connected", connection_id=connection_id, user_id=user_id)
    
    def disconnect(self, connection_id: str, user_id: str = None):
        """Remove a WebSocket connection"""
        if connection_id in self.active_connections:
            del self.active_connections[connection_id]
        
        if user_id and user_id in self.user_connections:
            self.user_connections[user_id].discard(connection_id)
            if not self.user_connections[user_id]:
                del self.user_connections[user_id]
        
        logger.info("WebSocket disconnected", connection_id=connection_id, user_id=user_id)
    
    async def send_json(self, connection_id: str, data: dict):
        """Send JSON data to a specific connection"""
        if connection_id in self.active_connections:
            websocket = self.active_connections[connection_id]
            if websocket.client_state == WebSocketState.CONNECTED:
                try:
                    await websocket.send_json(data)
                    return True
                except Exception as e:
                    logger.error("Error sending WebSocket message", error=str(e), connection_id=connection_id)
        return False
    
    async def broadcast_to_user(self, user_id: str, data: dict):
        """Broadcast message to all connections for a user"""
        if user_id not in self.user_connections:
            return False
        
        success = False
        for connection_id in list(self.user_connections[user_id]):
            if await self.send_json(connection_id, data):
                success = True
        
        return success


# Create a global connection manager
manager = ConnectionManager()


@router.websocket("/notifications/ws")
async def websocket_endpoint(
    websocket: WebSocket,
    token: str = Query(None),
    user_id: str = Query(None)
):
    """WebSocket endpoint for notifications"""
    
    connection_id = str(uuid.uuid4())
    
    # Validate authentication
    if token:
        try:
            payload = jwt_handler.decode_token(token)
            user_id = payload.get("user_id")
        except Exception as e:
            await websocket.close(code=1008, reason="Invalid authentication token")
            return
    
    # Connect to WebSocket
    try:
        await manager.connect(websocket, connection_id, user_id)
        
        # Send welcome message
        await websocket.send_json({
            "type": "connection_established",
            "connection_id": connection_id,
            "user_id": user_id,
            "timestamp": datetime.now().isoformat()
        })
        
        # Keep connection alive and handle messages
        try:
            while True:
                # Wait for messages
                data = await websocket.receive_text()
                try:
                    message = json.loads(data)
                    # Process messages
                    await websocket.send_json({
                        "type": "acknowledgement",
                        "message_id": message.get("id", str(uuid.uuid4())),
                        "timestamp": datetime.now().isoformat()
                    })
                except json.JSONDecodeError:
                    await websocket.send_json({
                        "type": "error",
                        "error": "Invalid JSON format",
                        "timestamp": datetime.now().isoformat()
                    })
        except WebSocketDisconnect:
            manager.disconnect(connection_id, user_id)
        
    except Exception as e:
        logger.error("WebSocket error", error=str(e), connection_id=connection_id)
        if websocket.client_state == WebSocketState.CONNECTED:
            await websocket.close(code=1011, reason="Internal server error")
        manager.disconnect(connection_id, user_id)
