"""
File upload routes for handling file imports and processing.
"""

import os
import uuid
import aiofiles
from pathlib import Path
from typing import List, Optional
from fastapi import APIRouter, UploadFile, File, Form, HTTPException, Depends
from fastapi.responses import JSONResponse
import structlog
from datetime import datetime

from .auth import get_current_user
from utils.file_utils import detect_file_type, detect_language
from core.orchestrator import get_orchestrator
from models.api.auth_models import User
from models.api.file_models import FileMetadata, FileUploadResponse, FileType

logger = structlog.get_logger(__name__)
router = APIRouter()

# Configure upload directory
UPLOAD_DIR = Path("data/uploads")
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

# Maximum file size (10MB)
MAX_FILE_SIZE = 10 * 1024 * 1024

# Allowed file types for processing
ALLOWED_EXTENSIONS = {
    '.txt', '.md', '.py', '.js', '.ts', '.jsx', '.tsx', '.html', '.css', 
    '.scss', '.sass', '.json', '.yaml', '.yml', '.xml', '.csv', '.sql',
    '.java', '.cpp', '.c', '.cs', '.php', '.rb', '.go', '.rs', '.swift',
    '.kt', '.scala', '.dart', '.vue', '.svelte', '.r', '.m', '.pl', '.sh',
    '.bash', '.zsh', '.fish', '.ps1', '.bat', '.dockerfile', '.makefile',
    '.gitignore', '.env', '.ini', '.cfg', '.conf', '.log'
}

async def save_uploaded_file(file: UploadFile, user_id: str) -> tuple[str, FileMetadata]:
    """Save uploaded file to disk and return file path and metadata"""
    
    # Validate file size
    content = await file.read()
    if len(content) > MAX_FILE_SIZE:
        raise HTTPException(
            status_code=413, 
            detail=f"File too large. Maximum size is {MAX_FILE_SIZE // (1024*1024)}MB"
        )
    
    # Reset file pointer
    await file.seek(0)
    
    # Validate file extension
    file_extension = Path(file.filename).suffix.lower() if file.filename else ''
    if file_extension not in ALLOWED_EXTENSIONS and file_extension:
        raise HTTPException(
            status_code=400,
            detail=f"Unsupported file type: {file_extension}. Allowed types: {', '.join(sorted(ALLOWED_EXTENSIONS))}"
        )
    
    # Generate unique filename
    file_id = str(uuid.uuid4())
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    safe_filename = "".join(c for c in file.filename if c.isalnum() or c in "._-") if file.filename else "unknown"
    unique_filename = f"{timestamp}_{file_id}_{safe_filename}"
    
    # Create user-specific directory
    user_upload_dir = UPLOAD_DIR / user_id
    user_upload_dir.mkdir(exist_ok=True)
    
    file_path = user_upload_dir / unique_filename
    
    # Save file
    async with aiofiles.open(file_path, 'wb') as f:
        content = await file.read()
        await f.write(content)
    
    # Detect file type and language
    content_str = content.decode('utf-8', errors='ignore')
    detected_file_type = await detect_file_type(str(file_path))
    detected_language = await detect_language(str(file_path))
    
    # Create metadata
    metadata = FileMetadata(
        filename=file.filename or "unknown",
        file_id=file_id,
        content_type=file.content_type or "application/octet-stream",
        size=len(content),
        file_type=detected_file_type,
        language=detected_language,
        checksum="",  # Will be generated by validator
        uploaded_at=datetime.now(),
        status="completed"
    )
    
    return str(file_path), metadata

@router.post("/import/file", response_model=FileUploadResponse)
async def upload_file(
    file: UploadFile = File(...),
    filename: str = Form(None),
    current_user: User = Depends(get_current_user)
):
    """Upload and process a single file."""
    try:
        user_id = current_user.id if current_user else "anonymous"
        
        # Override filename if provided in form
        if filename:
            file.filename = filename
        
        # Save file and get metadata
        file_path, metadata = await save_uploaded_file(file, user_id)
        
        # Process the file with the orchestrator
        orchestrator = get_orchestrator()
        
        # Read file content
        async with aiofiles.open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = await f.read()
        
        # Process the file (simplified without AI)
        result = await orchestrator.process_file(metadata, content)
        
        return FileUploadResponse(
            success=True,
            message="File uploaded and processed successfully",
            file_id=metadata.file_id,
            filename=metadata.filename,
            status=result.status,
            size=metadata.size,
            file_type=metadata.file_type,
            language=metadata.language,
            processed_at=result.processed_at
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error processing file upload: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"File upload failed: {str(e)}"
        )

@router.get("/import/status/{file_id}")
async def get_file_status(
    file_id: str,
    current_user: User = Depends(get_current_user)
):
    """Get the processing status of an uploaded file."""
    try:
        orchestrator = get_orchestrator()
        result = await orchestrator.get_file_processing_status(file_id)
        
        if not result:
            raise HTTPException(
                status_code=404,
                detail=f"File with ID {file_id} not found"
            )
        
        return {
            "success": True,
            "file_id": file_id,
            "status": result.status,
            "processed_at": result.processed_at,
            "error": result.error
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error checking file status: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to check file status: {str(e)}"
        )
